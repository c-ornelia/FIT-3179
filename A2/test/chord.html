<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pokemon Type Dominance Chord Diagram</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .ribbon { fill-opacity: 0.6; stroke: #000; stroke-width: 0.5px; }
    .group-label { font-size: 12px; text-anchor: middle; }
  </style>
</head>
<body>
  <svg width="800" height="800"></svg>
  <script>
    const svg = d3.select("svg"),
          width = +svg.attr("width"),
          height = +svg.attr("height"),
          outerRadius = Math.min(width, height) / 2 - 50,
          innerRadius = outerRadius - 20;

    const g = svg.append("g").attr("transform", `translate(${width/2},${height/2})`);

    // Load CSV
    d3.csv("type_dominance.csv").then(data => {

      // Get unique types
      const types = Array.from(new Set(data.flatMap(d => [d.Dominant, d.Submissive])));

      // Map type to index
      const index = new Map(types.map((t,i) => [t,i]));

      // Build matrix
      const matrix = Array.from({length: types.length}, () => Array(types.length).fill(0));
      data.forEach(d => {
        const i = index.get(d.Dominant);
        const j = index.get(d.Submissive);
        matrix[i][j] = +d["Dominant Factor"];   // outgoing
        matrix[j][i] = +d["Submissive Factor"]; // incoming
      });

      // Chord layout
      const chord = d3.chord()
                      .padAngle(0.05)
                      .sortSubgroups(d3.descending)
                      (matrix);

      const color = d3.scaleOrdinal(d3.schemeCategory10).domain(types);

      // Draw ribbons
      g.append("g")
        .selectAll("path")
        .data(chord)
        .enter()
        .append("path")
          .attr("class", "ribbon")
          .attr("d", d3.ribbon().radius(innerRadius))
          .style("fill", d => color(types[d.source.index]))
          .style("stroke", d => d3.rgb(color(types[d.source.index])).darker());

      // Draw outer arcs
      const group = g.append("g")
        .selectAll("g")
        .data(chord.groups)
        .enter()
        .append("g");

      group.append("path")
        .style("fill", d => color(types[d.index]))
        .style("stroke", d => d3.rgb(color(types[d.index])).darker())
        .attr("d", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius));

      // Draw labels
      group.append("text")
        .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
        .attr("dy", ".35em")
        .attr("class", "group-label")
        .attr("transform", d => `
          rotate(${d.angle * 180/Math.PI - 90})
          translate(${outerRadius + 10})
          ${d.angle > Math.PI ? "rotate(180)" : ""}
        `)
        .text(d => types[d.index]);

    });
  </script>
</body>
</html>
